---
Description: This file is about the kruskal.
---
# 克鲁斯卡尔算法
### 1.克鲁斯卡尔算法思想
>每次找出侯选边中权重最小的边，就将该边并入生成树中。重复此过程直到所有边都被检测完为止。
### 2.克鲁斯卡尔算法的执行过程
>将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为侯选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前树中，直到所有变都没检查完为止。
>>判断是否产生回路要用到并查集。并查集中保存了一棵树或者几棵树，这些树有这样的特点：通过树中一个结点，可以找到其双亲结点，进而找到跟结点（双亲存储结构）
>>>代码如下：
```c
typedef struct
{
	int a,b;		//边的两个端点
	int w;			//边的权重
}Road;
Road road[maxSize];
int v[maxSize];
int gerRoot(int a)	//并查集中查找根节点的方法。
{
	while(a!=v[a]) a=v[a];
	return a;
}
void Kruskal(MGraph g,int &sum,Road road[])
{
	int i;
	int N,E,a,b;
	N=g.n;
	E=g.e;
	sum=0;
	for(i=0;i<n;++i) v[i]=i;
	sort(road,E);				//对road数组中的E条边按其权值从小到大排序
	for(i=0;i<E;++i)
	{
		a=getRoot(road[i].a);
		b=getRoot(road[i].b);
		if(a!=b)
		{
			v[a]=b;
			sum+=road[i].w;	//求生成树的权值。
		}
	}
}
```
### 3.克鲁斯卡尔算法时间复杂度分析
>从算法代码中可以看出，算法时间主要花费在函数sort()和单层循环上，循环是线性级的，可以认为算法时间主要花费在函数sort()上，以为排序算法复杂度一般都高于常量级，因此克鲁斯卡尔算法的时间复杂度主要由选取的排序算法决定。而排序算法所处理的数据是由图的边数e决定，所以克鲁斯卡尔算法适用于稀疏图。
### p197 [例7-4]什么样的图其最小生成树是唯一的
>所有权值均不相等或者有相等的边，但是在构造最小生成树的过程中权值相等的边都被并入生成树中。
### [例7-5]已知带权连通图的邻接表表示如图所示，
