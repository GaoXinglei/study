---
Description: the file is about the insert sort.
---
# 插入类排序
## 1.直接插入排序
1. 算法思维：每趟将一个待排序的关键字按照其值的大小插入到已经排序好的部分有序序列的适当部分，直到所有待排序关键字都被插入到有序序列为止。
2. 算法代码：
```c
void InsertSort(int R[],int n)
{
	int i,j;
	int temp;
	for(i=0;i<n;++i)
	{
		temp=R[i];
		j=i-1;
		while(j>=0&&temp<R[j])
		{
			R[j+1]=R[j];
			--j;
		}
		R[j+1]=temp;
	}
}
```
3. 算法性能分析：
**1.时间复杂度**
>1)考虑最坏情况，取R[j+1]=R[j]这句为基本操作，若整个顺序为逆序，则每次这句基本操作都会执行，一共的执行次数为n(n-1)/2，可以看出时间复杂度为O(n^2)。<br>
>>2)考虑最好情况，则每次基本操作都不执行，双层循环为单层循环，则时间复杂度为O(n)。
>>>综上所述，此算法的时间复杂度为O(n^2)。
**空间复杂度：**
因算法所需要的辅助存储空间不随待排序序列规模的变化而变化，所以空间复杂度为O(1)。
## 2.折半插入排序
折半插入排序的算法思维和直接插入排序的基本相同，不同的是插入位置的查找不同。采取折半查找法。
算法如下：
```c
void halfInsertSort(int R[],int n)
{
	int i;m;low;high;
	int temp;
	for(i=0;i<n;++i)
	{
		temp=R[i];
		low=0;
		high=i-1;
		while(low<=high)
		{
			m=(low+high)/2;
			if(temp>R[m])	low=m+1;
			else	high= m-1;
		}
		for(int j=i;j>low;--j)	R[j]=R[j-1];
		R[low]=temp;
	}
}
```
算法性能基本与直接插入排序相同；
不同的是时间复杂度的最好情况此时为O(nlog2n);
## 3.希尔排序
1. 算法介绍
>希尔排序又叫**缩小增量排序**，其本质还是插入排序，这个规则体现在增量的选择上。增量由大到小最终到1；
2. 执行流程
参照书籍P238，特别注意：**希尔排序是不稳定排序**
算法：
```c
void shellSort(int arr[],int n)
{
	int temp;
	for(int gap=n/2;gap>0;gap/=2)
	{
		for(int i=gap;i<n;++i)
		{
			temp=arr[i];
			int i;
			for(j=i;j>=gap&&arr[j-tap]>temp;j-=gap)
				arr[j]=arr[j-gap];
			arr[j]=temp;
		}
	}
}
```
3. 性能分析<br>
	1.**时间复杂度**（根据增量序列的选取不同复杂度不一样）<br>
	1)希尔（shell）自己提出的增量选取方法：<br>
	n/2、n/2^2、.....、2、1<br>
	即每次将增量除以2并向下取整，其中n为序列长度，时间复杂度为O(n^2)。<br>
	2)帕佩尔诺夫和斯塔舍维奇(Papernov&Stasevich)提出的：<br>
	2^k+1、.....、65、33、17、9、5、3、1。<br>
	此时时间复杂度为O(n^1.5)。<br>
	**增量选取的两个注意的地方：1.增量序列最后一个值一定是1;2.增量序列的值应该尽量选没有除1以外的公因子。**<br>
	2.**空间复杂度**<br>
		空间复杂度与简单插入排序相同为O(1);
